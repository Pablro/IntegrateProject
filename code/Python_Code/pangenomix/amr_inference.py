#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
Created on Wed Jul 28 19:55:48 2021

@author: jhyun95

Scripts for inferring SIR AMR phenotypes from MICs, based on
previously observed MIC-SIR pairs on PATRIC
"""

import collections
import numpy as np
import pandas as pd

NULL_TESTING_STANDARDS = {'missing'} # testing standard to treat as null
ACCEPTED_MIC_METHODS = {
    'mic', 'broth_microdilution', 'agar_dilution', 'vitek_2',
    'etest', 'agar_dilution_or_etest', 'sensititre', 'bd_phoenix',
    'mic broth microdilution', 'bd_phoenix_and_etest', 'liofilchem'
} # lab methods on PATRIC that provide MIC values (laboratory_typing_method)
MIC_EQUALITY_SIGNS = {np.nan, '=', '=='} # MIC equality signs accepted by infer_sir()
MIC_INEQUALITY_SIGNS = {'>','>=','<','<='} # MIC inequality signs accepted by infer_sir()
MIC_BOUNDING_CASES = [('susceptible',{'<','<='}), ('resistant',{'>','>='})] # MIC bounding for infer_sir()

    
def infer_sir(org, antibiotic, measurement_value, measurement_sign, 
              mic_ranges, df_case_to_standard):
    ''' 
    Attempts to infer SIR phenotype from MIC values based on previously
    observed MIC values associated with SIR phenotypes (i.e. reverse
    engineered breakpoints).
    
    Parameters
    ----------
    org : string
        Organism name, used for looking up (organism x drug) case
    antibiotic : string
        Drug name, used for looking up (organism x drug) case
    measurement_value : string
        Raw MIC measured value, excluding inequality symbols
    measurement_sign : string
        Raw MIC measured value sign (np.nan, =, ==, <, >, <=, >=)
    mic_ranges : dict
        Mapping of (organism,drug,standard):SIR:[observed MICs],
        generated by extract_mic_sir_mappings()
    df_case_to_standard : pd.Series
        Series mapping "org|drug" pairs to primary standards, i.e. based
        on the "top_stnd" column generated by extract_primary_stnds()
    
    Returns
    -------
    sir : string
        Predicted SIR phenotype, or np.nan
    primary_stnd : string
        Standard for SIR prediction, or np.nan
    '''
    ''' Checking for combination therapy MICs '''
    try: # checking for combination therapies
        mic_val = float(measurement_value)
        mic_is_numeric = True
    except ValueError:
        mic_is_numeric = False
    is_likely_combo = __is_combination_therapy__(antibiotic) or not mic_is_numeric
    
    ''' Check that case has enough MIC reference data '''
    case = org + '|' + antibiotic
    if case in df_case_to_standard.index: 
        primary_stnd = df_case_to_standard[case]
        entry = (org, antibiotic, primary_stnd)
        if entry in mic_ranges: 
            case_mic_ranges = mic_ranges[entry]
            
            ''' MIC -> SIR inferences'''
            if measurement_sign in MIC_EQUALITY_SIGNS: # exact MIC, check S, I, R
                for sir in case_mic_ranges:
                    if measurement_value in case_mic_ranges[sir]: # check if MIC was previously observed 
                        return sir, primary_stnd
                    elif not is_likely_combo: # numeric MIC for single therapy, check range
                        sir_min = min(case_mic_ranges[sir])
                        sir_max = max(case_mic_ranges[sir])
                        mic_val = float(measurement_value)
                        if (sir == 'susceptible' or mic_val >= sir_min) and\
                           (sir == 'resistant' or mic_val <= sir_max):
                            return sir, primary_stnd
                        
            elif measurement_sign in MIC_INEQUALITY_SIGNS: # bounded MIC, check S and R only
                ''' Check if MIC is less than known S MIC, or greater than known R MIC '''
                for sir, sir_signs in MIC_BOUNDING_CASES:
                    if sir in case_mic_ranges and measurement_sign in sir_signs:
                        if measurement_value in case_mic_ranges[sir]: # check exact matches
                            return sir, primary_stnd
                        elif not is_likely_combo: # numeric MIC for single therapy, check range
                            sir_min = min(case_mic_ranges[sir])
                            sir_max = max(case_mic_ranges[sir])
                            mic_val = float(measurement_value)
                            if (sir == 'susceptible' or mic_val >= sir_min) and\
                               (sir == 'resistant' or mic_val <= sir_max):
                                return sir, primary_stnd
    return np.nan, np.nan


def extract_mic_sir_mappings(df_mic_calls, df_case_to_standard, 
    minimum_calls=3, allowed_sirs={'susceptible', 'resistant', 'intermediate'}):
    '''
    Extracts MIC-SIR mappings for (organism,drug) cases in the provided
    primary standards, to be used in inferring SIRs from MICs.
    
    Parameters
    ----------
    df_mic_calls : pd.DataFrame
        Unique MIC calls, from extract_mic_calls()
    df_case_to_standard : pd.Series
        Series mapping "org|drug" pairs to primary standards, i.e. based
        on the "top_stnd" column generated by extract_primary_stnds()
    minimum_calls : int
        Minimum number of times to observe an (organism x drug)-specific 
        MIC-SIR call to treat the MIC-SIR mapping as a reference (default 3)
    allowed_sirs : set
        SIR values for which to create reference MIC-SIR mappings
        (default {'susceptible', 'resistant', 'intermediate'})

    Returns
    -------
    mic_ref_calls : dict
        Nested dictionary mapping (organism,drug,standard):MIC:SIR:count.
        All MICs are still strings in this format.
    mic_ranges : dict
        Nested dictionary mapping (organism,drug,standard):SIR:[observed MICs].
        MICs are converted to floats whenever possible. Exceptions include MICs 
        for combination therapies that include slashes, left as strings.
    '''
    mic_ref_calls = {} # {(org, drug, stnd):mic:sir:count}
    for org in df_mic_calls.organism.unique():
        df_org_mics = df_mic_calls[df_mic_calls.organism == org]
        df_org_mics = df_org_mics[df_org_mics['count'] >= minimum_calls] # only use mappings with enough calls
        df_org_mics = df_org_mics[pd.isnull(df_org_mics.mic_sign)] # only use exact MIC calls 
        for drug in df_org_mics.drug.unique():
            case = org + '|' + drug
            if case in df_case_to_standard.index:
                case_stnd = df_case_to_standard[case]
                df_org_drug = df_org_mics[df_org_mics.drug == drug]
                df_org_drug_stnd = df_org_drug[df_org_drug.standard == case_stnd]
                for row in df_org_drug_stnd.itertuples(name=None):
                    i, org, drug, stnd, sir, mic, mic_sign, mic_val, count = row
                    if sir in allowed_sirs:
                        entry = (org, drug, stnd)
                        if not entry in mic_ref_calls:
                            mic_ref_calls[entry] = {}
                        if not mic in mic_ref_calls[entry]:
                            mic_ref_calls[entry][mic] = {}
                        mic_ref_calls[entry][mic][sir] = count
    
    mic_ranges = {} # {(org, drug, stnd):sir:[observed MICs]}
    for case in mic_ref_calls:
        mic_ranges[case] = {sir:[] for sir in allowed_sirs}
        is_combination_therapy = False
        for mic in mic_ref_calls[case]:
            for sir in mic_ref_calls[case][mic]:
                is_combination_therapy = is_combination_therapy or '/' in mic
                if not '/' in mic:
                    mic_ranges[case][sir].append(float(mic))
                else:
                    mic_ranges[case][sir].append(mic)
        for sir in allowed_sirs:
            if len(mic_ranges[case][sir]) == 0:
                del mic_ranges[case][sir]
            else: 
                mic_ranges[case][sir] = sorted(mic_ranges[case][sir])
    return mic_ref_calls, mic_ranges


def validate_mic_sir_mappings(mic_ref_calls, mic_ranges):
    '''
    Checks for inconsistencies and combination therapies in 
    reference MIC calls. Specifically checks for the following:
        - Ambiguous: Same MIC mapped to multiple SIRs in a (organism x drug) case
        - Inconsistent1: Susceptible MIC > Intermediate or Resistant MIC
        - Inconsistent2: Resistant MIC < Intermediate or Susceptible MIC
        
    Parameters
    ----------
    mic_ref_calls : dict
        From extract_mic_sir_mappings() {(organism,drug,standard):MIC:SIR:count}
    mic_ranges : dict
        From extract_mic_sir_mappings() {(organism,drug,standard):SIR:[observed MICs]}
    '''
    
    ''' Checking for Ambiguous MICs: Same MIC assigned to multiple SIRs '''
    for case in sorted(mic_ref_calls.keys()):
        for mic in mic_ref_calls[case]:
            calls = mic_ref_calls[case][mic]
            if len(calls) > 1:
                print 'AMBIGUOUS MIC-SIR:\t', '\t'.join(case), '\t', mic, mic_ref_calls[case][mic]
                
    ''' Checking for Inconsistent MICs: S > I, S > R, or I > R (also report combination therapies) '''
    for case in sorted(mic_ref_calls.keys()):
        is_combination_therapy = False
        for mic in mic_ref_calls[case]:
            for sir in mic_ref_calls[case][mic]:
                is_combination_therapy = is_combination_therapy or '/' in mic
        if not is_combination_therapy:
            has_s = 'susceptible' in mic_ranges[case]
            has_i = 'intermediate' in mic_ranges[case]
            has_r = 'resistant'in mic_ranges[case]
            if has_s and has_i: # check susceptible < intermediate
                s_vs_i = max(mic_ranges[case]['susceptible']) < min(mic_ranges[case]['intermediate'])
                if not s_vs_i:
                    print 'INCONSISTENT S vs I:\t', '\t'.join(case), '\t', mic_ranges[case]
            if has_s and has_r: # check susceptible < resistant
                s_vs_r = max(mic_ranges[case]['susceptible']) < min(mic_ranges[case]['resistant'])
                if not s_vs_r:
                    print 'INCONSISTENT S vs R:\t', '\t'.join(case), '\t', mic_ranges[case]
            if has_i and has_r: # check intermediate < resistant
                i_vs_r = max(mic_ranges[case]['intermediate']) < min(mic_ranges[case]['resistant'])
                if not i_vs_r:
                    print 'INCONSISTENT I vs R:\t', '\t'.join(case), '\t', mic_ranges[case]
        else:
            print 'COMBINATION THERAPY:\t', '\t'.join(case), '\t', mic_ranges[case]


def extract_mic_calls(org_to_gids, df_amr, min_entries=100):
    '''
    Counts unique MIC measurements for organism x drug cases with 
    sufficient data, yields mg/L values, and are derived from 
    laboratory methods in ACCEPTED_MIC_METHODS. Consolidates exact
    MIC measurements (sign = np.nan, "=", "==") to sign = np.nan.
    
    Parameters
    ----------
    org_to_gids : dictionary
        Dictionary mapping species to list of PATRIC genome IDs
    df_amr : pd.DataFrame
        DataFrame in the format of PATRIC_genomes_AMR.txt
    min_entries : int
        Minimum number of AMR data rows required to analyze an 
        organism x drug case (default 100)
        
    Returns
    -------
    df_mic_calls : pd.DataFrame
        DataFrame with the columns organism, drug, standard,
        sir (usually "susceptible", "resistant", or "intermediate"),
        mic (raw reported MIC), mic_sign, mic_val, and count (number
        of times the MIC was assigned to the SIR value, for the 
        given organism x drug case)
    '''
    df_mic_calls = []
    for org in sorted(org_to_gids.keys()):
        ''' Extract organism-specific records '''
        gids = set(org_to_gids[org])
        df_org_amr = df_amr[df_amr.genome_id.map(lambda x: x in gids)]

        ''' Identify drugs with at least 100 entries, MIC or SIR '''
        drug_counts = df_org_amr.antibiotic.value_counts()
        df = drug_counts[drug_counts >= min_entries]
        target_drugs = set(df.index)

        ''' Identify clean(er) MIC data for selected drugs '''
        df_org_mic = df_org_amr[pd.notnull(df_org_amr.measurement)]
        df_org_mic = df_org_mic[df_org_mic.measurement_unit == 'mg/L']
        df_org_mic = df_org_mic[df_org_mic.antibiotic.map(lambda x: x in target_drugs)]
        df_org_mic = df_org_mic[df_org_mic.laboratory_typing_method.map(
            lambda x: x in ACCEPTED_MIC_METHODS)]

        ''' Extract MIC measurements '''
        mic_calls = []
        for row in df_org_mic.itertuples(name=None):
            i, gid, gname, taxid, drug, sir, mic, mic_sign, mic_val = row[:9]
            if mic_sign in {'=', '=='}:
                mic_sign = np.nan
            standard = row[-5]
            if pd.notnull(mic):
                if not standard in NULL_TESTING_STANDARDS:
                    entry = (org, drug, standard, sir, mic, mic_sign, mic_val)
                    mic_calls.append(entry)
        mic_calls = collections.Counter(mic_calls)
        for entry in sorted(mic_calls.keys()):
            df_mic_calls.append(list(entry) + [mic_calls[entry]])

    df_mic_calls = pd.DataFrame(data=df_mic_calls, 
        columns=['organism', 'drug', 'standard', 'sir', 
                 'mic', 'mic_sign', 'mic_val', 'count'])
    return df_mic_calls


def extract_primary_stnds(org_to_gids, df_amr, min_entries=100, stnd_col='testing_standard'):
    '''
    Identifies the most commonly used testing standard for a given
    organism x drug case, along with count data.
    
    Parameters
    ----------
    org_to_gids : dict
        Dictionary mapping species to list of PATRIC genome IDs
    df_amr : pd.DataFrame
        DataFrame in the format of PATRIC_genomes_AMR.txt
    min_entries : int
        Minimum number of AMR data rows required to analyze an 
        organism x drug case (default 100)
    stnd_col : str
        Name of column in df_amr to use as testing standard 
        (default "testing_standard")
        
    Returns
    -------
    df_primary_stnds : pd.DataFrame
        DataFrame indexed by "organism|antibiotic". Columns include:
            top_stnd: Most common non-null standard, usually "clsi" or "eucast"
            n_top_stnd: Number of rows labeled with top_stnd
            n_other_stnd: Number of rows labeled with other non-null standards
            n_missing_stnd: Number of rows without standard metadata
            other_stnds: Other non-null standards reported
    '''
    df_primary_stnds = {}
    for org in sorted(org_to_gids.keys()):
        org_gids = set(org_to_gids[org])
        df_org_amr = df_amr[df_amr.genome_id.map(lambda x: x in org_gids)]

        ''' Identify drugs with enough MIC and/or SIR datapoints '''
        drug_counts = df_org_amr.antibiotic.value_counts()
        df = drug_counts[drug_counts >= min_entries]
        target_drugs = set(df.index)

        ''' Identify counts for the most common standard, as well as
            other recorded standards and unlabeled data points '''
        for drug in target_drugs:
            df_drug_amr = df_org_amr[df_org_amr.antibiotic == drug]
            stnd_counts = df_drug_amr[stnd_col].value_counts(dropna=False)
            top_stnd = stnd_counts.index[0]
            top_stnd = stnd_counts.index[1] if pd.isnull(top_stnd) and stnd_counts.shape[0] > 1 else top_stnd
            other_stnds = filter(lambda x: pd.notnull(x) and x!= top_stnd, stnd_counts.index.tolist())
            n_top_stnd = stnd_counts[top_stnd]
            n_missing = stnd_counts.loc[np.nan] if np.nan in stnd_counts.index else 0
            n_other_stnd = df_drug_amr.shape[0] - n_top_stnd*(pd.notnull(top_stnd)) - n_missing
            other_stnds_out = ';'.join(other_stnds) if len(other_stnds) > 0 else np.nan
            df_primary_stnds[org + '|' + drug] = {
                'top_stnd': top_stnd,
                'n_top_stnd': n_top_stnd,
                'n_other_stnd': n_other_stnd,
                'n_missing_stnd': n_missing,
                'other_stnds': other_stnds_out
            }
    df_primary_stnds = pd.DataFrame.from_dict(df_primary_stnds, orient='index')
    df_primary_stnds = df_primary_stnds.reindex(columns=
        ['top_stnd', 'n_top_stnd', 'n_other_stnd', 'n_missing_stnd', 'other_stnds'])
    return df_primary_stnds


def __is_combination_therapy__(antibiotic):
    ''' Check if an antibiotic is a combination therapy '''
    if antibiotic == 'polymyxin_b' or antibiotic == 'nalidixic_acid':
        return False
    elif '_' in antibiotic:
        return True
    else:
        return False